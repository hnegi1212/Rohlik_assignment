# Rohlik Group — ML Engineer Take-Home (Pricing + Forecasting)

This repository contains a complete, runnable Python solution for the Rohlik Group ML Engineer assignment:

- **Objective 1 — Optimal Pricing:** choose sell prices for **5 products** over the **next 7 days** to maximize **total 7-day revenue**, while ensuring total profit over those 7 days is at least **7× the profit from the last day**.
- **Objective 2 — Sales Forecasting:** predict sales for each product for the next 7 days assuming **sell_price stays the same as the last day**.

The implementation is intentionally designed to be:
- **Production-style** (baselines + validation + model selection)
- **Constrained-optimization aware** (profit constraint is enforced)
- **Explainable and safe** (monotonic demand constraints to prevent nonsensical price→demand behavior)

---

## Contents

- `rohlik_solution.py` — main script (end-to-end)
- `ml_task_data.csv` — input dataset (provided by Rohlik)
- Outputs generated by the script:
  - `objective2_forecast.csv`
  - `objective1_optimal_pricing.csv`
  - `model_selection.csv`
  - `approach_comparison.csv`

---

## Data & Key Definitions

The dataset contains daily observations for each product, including:
- `sell_price`
- `sales`
- `margin`

We derive:
- `buy_price = sell_price - margin`

**Profit and Revenue:**
- Revenue = `sales * sell_price`
- Profit = `(sell_price - buy_price) * sales`

**Important constraint from the assignment:**
- Use the **last day’s buy_price** for all future 7 days.
- Profit constraint:  
  \[
  Profit_{7d} \ge 7 \times Profit_{last\ day}
  \]

---

## What’s Implemented (High Level)

### Objective 2 — Forecasting (3 approaches + automatic selection)
We implement **three forecasting approaches** and select the best **per product** via time-based validation (sMAPE):

1) **Weekday seasonal baseline (DOW mean)**
   - Predict sales by average historical sales for the same weekday.
   - Reason: grocery demand often shows strong weekly seasonality; a baseline is a must for credibility.

2) **CatBoost global forecaster**
   - A single model trained across all products with `product_id` as a categorical feature.
   - Uses calendar features + lag/rolling features.
   - Reason: modern high-performing tabular model; strong non-linear learning; robust on small/medium data.

3) **LightGBM quantile forecaster (median)**
   - Global model trained with quantile objective (α=0.5).
   - Reason: robust to outliers; aligns with uncertainty-aware forecasting practices.

**Why “global models”?**
- Products often share temporal patterns (seasonality, trend).
- Global models usually generalize better than per-product models when data per item is limited.

**Recursive forecasting**
- For ML models, forecasts are generated day-by-day because lag features for day `t+2` depend on predicted sales for day `t+1`.

---

### Objective 1 — Demand Modeling for Pricing (3 approaches + selection)
Pricing requires a counterfactual model: **sales as a function of price**. We fit **per-product** demand models and select the best per product via time holdout:

1) **Log–log Ridge (elasticity-style)**
   - Models `log1p(sales)` ~ `log(price)` + time features.
   - Reason: interpretable and stable; provides an economic baseline (elasticity proxy).

2) **LightGBM with monotonic constraint on price**
   - Enforces: increasing `sell_price` should not increase predicted demand.
   - Reason: prevents unrealistic demand curves that optimizers would exploit.

3) **CatBoost with monotonic constraint on price**
   - Same monotonic principle with an alternative model family.
   - Reason: sometimes outperforms LGBM depending on noise / data shape.

**Why monotonic constraints matter**
- In pricing, an unconstrained ML model can learn artifacts like “higher price → higher demand”.
- Optimizers will exploit these artifacts, producing unsafe price recommendations.
- Monotonicity makes the optimization more business-faithful and stable.

---

### Objective 1 — Pricing Optimization (3 approaches + best feasible selection)
We solve the constrained revenue-maximization problem using discrete price candidates. The system evaluates three optimization strategies:

1) **Constant price per product (baseline)**
   - One price per product across the 7 days.
   - Reason: highly interpretable; operationally simple; good fallback baseline.

2) **Greedy profit repair**
   - Start with revenue-maximizing prices (ignoring the profit constraint).
   - If total profit is below the threshold, raise prices in the best “profit gain per revenue loss” moves until feasible.
   - Reason: pragmatic, fast, and often near-optimal under tight constraints.

3) **Lagrangian relaxation + binary search**
   - Solve: maximize `revenue + λ * profit`
   - Binary search λ to meet the profit constraint with minimal revenue sacrifice.
   - Reason: standard constrained-optimization technique; robust and scalable for discrete options.

**Final selection**
- Among all feasible solutions, the script chooses the approach with the **highest total expected revenue**.

---

## How to Run

### 1) Install dependencies
Create a virtual environment and install:

```bash
pip install -U pandas numpy scikit-learn lightgbm catboost


### 2) Run the script
python rohlik_solution.py
